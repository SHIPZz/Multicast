Архитектура тестового задания:
BootstrapInstaller – биндинг сервисов, делаем некий хак и биндним Initialize к инсталлеру и сразу переходим в Initialize, а из него в BootstrapState. 
BootstrapState – биндит окна через WindowService, загружает данные из адрессаблов(весь контент сделан через адрессаблы) при помощи сервиса для адрессаблов, проверяет интернет, если его нет, мы через сервис для проверки интернета проверяем каждые 3 секунды интернет и дожидаемся, пока он будет и затем закрываем окно нет интернета, инициализируем unity remote config, загружаем все сохраненные данные, инициализируем систему, которая будет сейвить при потере фокуса, переходим в LoadingMenuState.
LoadingMenuState – при помощи sceneloader просто переходим в Menu, а после загрузки сцены из адрессаблов мы заходим в MenuState.
MenuState – закрываем все окна, открываем окно Menu.
CleanupBeforeLoadingGameState – используется для очистки сервисов связанных с игрой, после переходим в лоад гейм стейт.

LoadGameState – проверяет интернет, закрываем все окна, загружает сцену гейм и после переходим в GameState

GameState – инициализация игры, мы получаем текущий сохраненный уровень,
инициализируем слова, которые нужно найти, кластеры под эти слова,
сервис для подсказок, сервис для работы кластера и сервис для ячеек

Работа с ячейками и кластерами разделена в сервисах – clusterservice, cluster repository,cluster placement, wordslot service, wordslot repository.

Префабы берутся с помощью  StaticDataService и AssetProvider, берутся из адрессаблов.
Также было выполнено сохранение данных в PlayerPrefsSaveSystem, все те, кто наблюдают за прогрессом и его сохраняют реализуют интерфейс IProgressWatcher с методами Load(ProgressData), Save(ProgressData). Было выполнено сохранение и восстановление текущего прогресса.
Также сделана простая система подсказок с помощью HintService, HintConfig.
Сделана простая работа со звуками через SoundPlayerView, SoundConfig, SoundService, звуки тоже в адрессаблах.
Работа с окнами реализована через MVC, при помощи WindowService, мы можем забиндить Контроллер и Вью, либо Контроллер, Вью, Модель. В моем случае вместо моделей я использую сервисы в контроллерах, Controller “управляет” View и сетит ему данные
Помимо всего этого, я сделал автоматическую загрузку адрессаблов и билда под любую платформу на SDN Yandex storage, при помощи Amazon S3 SDK после того, как собрался билд.
По оптимизации: с точки зрения кода, были минимизированы вызовы GC, например, выделение памяти для строк или коллекций в начале уровня(1 раз), а там, где часто требуется выделение памяти коллекций были использованы пулы(DictionaryPool, ListPool), также были заданы начальные емкости для каждой коллекций
С точки зрения UI, откючил raycast target, rich text у tmp, у ненужных image отключил также raycast target
